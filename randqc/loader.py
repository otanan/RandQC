#!/usr/bin/env python3
"""Module that handles loading in state files and other relevant data files.

**Author: Jonathan Delgado**

This module follows RandQC conventions to locate data files such as entropy data and saved states. This module also handles requesting more data to be generated if needed. The strength of this module comes from creating new behavior in the randqc.loader.Loader object.

Example:
    To create custom loading behavior such that special states can be loaded two things are needed: a relative path containing any special folders to store the states in (for separation from other data) and the naming convention individual state files should follow; the final thing is an instructions generator. A function which takes certain parameters and returns a string of instructions that can be parsed by randqc.tools.parser.parse_instructions. To illustrate this example consider the implementation of loader.Loader.get_randomly_doped_states. The path is generated by loader.Loader.get_randomly_doped_state_path, and the instructions generator is taken from randqc.rand_doping. With these created all that remains to be done is to call the abstracted function loader.Loader.abstract_get_states(N, input_state, path_generator, instructions_generator, *instructions_generator_args, num_states, data_only, state_to_image).

"""
from pathlib import Path
import numpy as np
import pickle # Legacy loading
import qutip as qt
import h5py # New entropy file IO standard

import randqc
import randqc.tools.parser as parser
import randqc.tools.paths as paths
import randqc.tools.gui as gui
import randqc.imager as imager
import randqc.saver as saver
from randqc.tools.paths import default_folder

# The random number generator meant for use only in this script. Takes over
    # for usage for random and np.random directly.
    # See: https://numpy.org/doc/stable/reference/random/index.html
_RNG = np.random.default_rng()


def is_serialized(entropy_data):
    """ Checks whether entropy data has been serialized.
        
        Args:
            entropy_data (numpy.ndarray): the entropy data.
    
        Returns:
            (bool): True if the entropy_data is properly serialized, False otherwise.
    
    """
    # Vacuously true if no data is provided
    if entropy_data.shape[0] == 0:
        return True

    return entropy_data[0, 0] < -0.99995


######################## IO functions ########################


def load_state(fname, state_to_image=False, data_only=False):
    """ Handles loading of quantum states with legacy code for handling states 
        saved previously using qutip or alternative saving functionality.
    
        Args:
            fname (pathlib.PosixPath/str): the path including the filename.

        Kwargs:
            state_to_image (bool): whether the state should be converted to an image.

            data_only (bool): whether to only load the data instead of returning an entire qutip.Qobj or PIL.Image.
    
        Returns:
            (qutip.Qobj/numpy.ndarray/PIL.Image): the loaded state in the requested format.
    
    """
    if type(fname) is str: fname = Path(fname)

    file_type = fname.suffix

    ### Loading ###
    
    if file_type == '.npz':
        with open(fname, 'r') as f:
            try:
                state = np.load(fname)['array1']
            # Potentially corrupt state file.
            # This has only happened thus far with .npz so we keep it here.
            except ValueError:
                raise ValueError(f'Unable to load state located at: {str(fname)}.\n Check to see if state file is corrupt or incomplete.')
    ### Legacy loading ###
    elif file_type == '.qu':
        # Legacy states
        # Copied from qutip source and adjusted to remove print statement
        # Source: http://qutip.org/docs/latest/modules/qutip/fileio.html#qload
        with open(fname, 'rb') as f:
            state = pickle.load(f, encoding='latin1')

    ### Error handling ###
    else: 
        print(f'Unsupported file extension: {file_type} for loading.')
        print('Exiting...')
        sys.exit()

    if state_to_image:
        state = imager.state_to_image(state, data_only=data_only)
        return state

    # We don't want an image, we want a state, but legacy loading will provide
        # a qutip.Qobj, new loading provides an numpy.ndarray.
    if data_only:
        if type(state) is qt.Qobj:
            state = state.full()

        return state

    else:
        # We want the state object but need to account for differences in 
            # loading
        if type(state) is np.ndarray:
            state = parser.qobj_from_array(state)
            return state

    
def load_states(directories, num_states_per_direc=0, data_only=True, state_to_image=False, verbose=True):
    """ Loads states from a collection of directories or a single directory 
        and returns the list of the prepared states (or images). Note this only supports a directory filled with the same type states, in other words, while state files can have different file extensions (.qu or .npz) it cannot be mixed with images.
    
        Args:
            directories (list/pathlib.PosixPath/str): the directory or list of directories.

        Kwargs:
            num_states_per_direc (int): the number of states to load from each provided directory. Provide a non-positive number to load all states.            

            data_only (bool): whether to load the states as only data or to turn them into proper qutip.Qobjs or Image objects.

            state_to_image (bool): whether to convert the states to images.

            verbose (bool): controls print statements.
            
        Returns:
            (list): the list of the loaded states in the requested format.
    
    """
    # Prepares the directory to use the same code code for when multiple 
        # directories are provided
    if type(directories) is not list:
        directories = [directories]
    # Convert paths to pathlib.PosixPath objects
    directories = [
        Path(directory) if type(directory) is not Path else directory
        for directory in directories
    ]

    # Loads the paths to each of the state files using the list of 
        # directories
    states_to_load = []

    #------------- Loading filenames -------------#

    for directory in directories:
        if verbose:
            print(f'States will be loaded from: {directory.name}')

        states_in_direc = list(directory.glob('state-*'))
        num_states_in_current_direc = len(states_in_direc)

        if num_states_in_current_direc == 0:
            # There's nothing in this folder, move on
            continue
        
        if num_states_per_direc > 0 and num_states_per_direc < num_states_in_current_direc:
            # Randomly select of the states available the number we want   
            states_in_direc = list(_RNG.choice(
                states_in_direc, size=num_states_per_direc, replace=False
            ))

        states_to_load += states_in_direc

    states = []

    #------------- Loading states -------------#
    
    for state_path in states_to_load:

        state = load_state(state_path, data_only=data_only, state_to_image=state_to_image)

        states.append(state)

    return states


def score_states(states, scoring_map, key=None, mask_nans=False, verbose=True, GUI=False):
    """ Takes a function (scoring_map) which maps states to lists (such as a 
        list of regularizers) and marks the output with the key. Useful for creating training datasets.
    
        Args:
            states (list): the states to be scored.

            scoring_map (function): a function which takes in a state and returns a list of values, i.e. regularizers for training on the data set.

        Kwargs:
            key: a marking for this collection of states (i.e. to
                mark them as either Clifford or Haar). Examples include 0 for Clifford, 1 for Haar, or 'clif' for Clifford, 'haar' for Haar. The data type of the key must match the data type of the scores.

            mask_nans (bool): removes any rows with nan values.

            verbose (bool): controls print statements.

            GUI (bool): whether to show a graphical loading progress to indicate progress.
    
        Returns:
            (numpy.ndarray): the results of the training
    
    """
    def mask():
        nonlocal scored_states
        nan_locs = np.any(np.isnan(scored_states), axis=1)
        if verbose:
            print(f'Masking {np.sum(nan_locs)/scored_states.shape[0]*100:.1f}% of scored states.')
        scored_states = scored_states[~nan_locs]

    # If a training key is provided we need to label our scores
    key = [key] if key != None else []

    if GUI: bar = gui.ProgressBar(len(states), title='Scoring states...')

    scored_states = []
    for state in states:
        # Order of key and scores is purely convention
        # key + scoring_map(state)
        scored_states.append(scoring_map(state) + key)

        if GUI: bar.update()

    scored_states = np.array(scored_states)
    if mask_nans: mask()

    if GUI: bar.finish()

    return scored_states


def _convert_to_images(states, data_only=True):
    # Handles converting a list of states to images IN PLACE.
    # Only used in loader.py where it is known that the original list of 
        # states is no longer of interest.

    print('Converting new states to images.')

    for i, state in enumerate(states):
        state = imager.state_to_image(state)
        # Overwrites the state with the image matrix
            # as a numpy matrix in the case where we only want the data
            # or the Image object if we are not just interested in data
        # image_states.append(np.array(state) if data_only else state)
        states[i] = np.array(state) if data_only else state

    print('New states converted to images successfully.')
    print()

    return states


def load_data(fname, num_trials=0, verbose=True):
    """ Loads the general data files from the provided fname. Including 
        entropy data or generic state data.
    
        Args:
            fname (pathlib.PosixPath/str): the path to the data file.

        Kwargs:
            num_trials (int): the number of trials to return. Use a non-positive number to indicate all of them.

            verbose (bool): controls print statements.
    
        Returns:
            (numpy.ndarray): the matrix of entropy data. Each row consists of a trial and each column consists of a gate, so the matrix will be of dimension: (num_trials)x(num_gates + 2) where the shift to the column accounts for the entropy of the initial state, and the serial of the state used to get this data in the leftmost column.
    
    """
    if type(fname) is str: fname = Path(fname)

    # Search for entropy files available, in the case of legacy files with
        # varying extensions this will be a non-trivial count. As well as when
        # there are various -core(i) files from cluster.
    # The folder provided is expected to be the filename without the extension.
    # To make it work with glob we need to manipulate it
    # Glob does not support brackets, we need to adjust our search
    fstem = str(fname.stem)
    if ']' in fstem:
        fstem = fstem.split(']')[0]

    to_load = list(fname.parent.glob(fstem + '*'))

    if len(to_load) == 0:
        return np.array([])

    data = np.array([])
    # If there is more data we need to append it to this one
    for fname in to_load:
        if num_trials > 0 and data.shape[0] >= num_trials:
            # We've gathered enough data
            break

        if verbose:
            print(f'State data will be loaded from: {fname.name}')

        file_type = fname.suffix

        # Checks extension for legacy support
        if file_type == '.hdf5':
            with h5py.File(fname, 'r') as f:
                new_data = f['default'][()]
        elif file_type == '.npy':
            new_data = np.load(fname)
        elif file_type == '.txt':
            new_data = np.loadtxt(fname)
        else:
            print(f'Invalid data file type: {fname}. Skipping...')
            continue

        # Cannot vertically stack if we have 0 rows of data.
        data = np.vstack( (data, new_data) ) if data.shape[0] != 0 else new_data

    # Check if the data is only a single trial, in which case the data will
        # have the shape (n,) for an n-1 gate circuit when it should be (1, n).
    if data.ndim == 1:
        data = np.reshape(data, (1, data.shape[0]))

    if verbose and not is_serialized(data):
        print('DATA IS UNSERIALIZED.')
        print('Please serialize data for future usage.')


    return data[:num_trials] if num_trials > 0 else data


class Loader:
    """ Handles loading in relevant data objects and requesting more when 
        needed.
    
        The loader.Loader object. Most interfacing with RandQC and data files 
        should be done through here when possible. Allows for data to be handled in separate directories should custom saving/loading be desired rather than the default IO.
        
        Attributes:
            root_path: the top-level folder containing files of interest. All other directories for file IO will be children to this folder.

            verbose: controls print statements.
    """


    def __init__(self, root_path=default_folder(), verbose=True):
        # Stores the base path to the folder
        # Ensures it is a proper PosixPath object
        self.root_path = Path(root_path)
        # Check if an unresolved path is provided and expand it
        if '~' in str(root_path):
            self.root_path = self.root_path.expanduser()

        self._verbose = verbose
        self.special_state_template = 'N({N})-q0({input_state})-n_T({n_T})-num_gates({num_gates})'


    #------------- Object properties -------------#

    @property
    def verbose(self):
        return self._verbose

    @verbose.setter
    def verbose(self, value):
        self._verbose = value


    #------------- Saving -------------#


    def save_state(self, state, N, input_state, instructions, topology='complete', identifier=''):
        """ Handles state saving in a manner that can be loaded again easily 
            using this object's functionality.
            
            Args:
                state (qutip.Qobj/numpy.ndarray): the state to be saved.

                N (int): the number of qubits for the system. Used for IO conventions.

                input_state (str): the initial_state that produced this one. Used for IO conventions.

                instructions (str): the instructions which generated the circuit which output this state. Used for IO conventions.
        
           Kwargs:
                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.

            Returns:
                (None): none
        
        """
        fname = paths.get_save_state_file_path(self.root_path, N, input_state, instructions, topology=topology, identifier=identifier)
        saver.save_state(state, fname)


    def save_entropies(self, data, N, input_state, instructions, bipartition=None, renyi_parameter=1, topology='complete', identifier=''):
        """ Handles entropy data saving in a manner that can be loaded again 
            easily using this object's functionality.
            
            Args:
                data (numpy.ndarray): the entropy data.

                N (int): the number of qubits for the system. Used for IO conventions.

                input_state (str): the initial_state that produced this entropy data. Used for IO conventions.

                instructions (str): the instructions which generated the circuit which generated this entropy data. Used for IO conventions.
        
            Kwargs:
                bipartition (int): the bipartition used for the entropy data. Used for IO conventions.

                renyi_parameter (float): the Renyi entropy gathered to generate this data. Used for IO conventions.

                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.


            Returns:
                (None): none
        
        """
        fname = paths.get_entropy_file_path(self.root_path, N, input_state, instructions, bipartition=bipartition, renyi_parameter=renyi_parameter, topology=topology, identifier=identifier)
        saver.save_entropies(data, fname=fname)


    #------------- Custom paths -------------#


    def get_randomly_doped_state_path(self, N, input_state, n_T, num_gates):
        """ Returns the path for the folder holding a collection of randomly 
            doped states with the above parameter set.
            
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates used to dope the circuit.

                num_gates (int): the number of gates in the circuit.
        
            Returns:
                (pathlib.PosixPath): the path to the state folder.
        
        """
        fname = self.special_state_template.format(N=N, input_state=input_state, n_T=n_T, num_gates=num_gates)

        return Path(
                self.root_path,
                'rand_doping',
                fname
            )


    def get_equal_gap_state_path(self, N, input_state, n_T, num_gates, dope_start=1, dope_end=None, gap=None, lead_T=False):
        """ Returns the path for the folder holding a collection of states 
            doped with T gates that are spaced equally far apart.
            
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates used to dope the circuit.

                num_gates (int): the number of gates in the circuit.

            Kwargs:
                dope_start (int): the position of the first gate (inclusively) for where doping is allowed to happen.

                dope_end (int/None): the position of the last gate (inclusively) for where doping is allowed to happen. Defaults to num_gates if None is provided.

                gap (int/None): the number of Clifford gates that should separate each T gate. Defaults to an equal space based on the number of gates requested if None is provided.

                lead_T (bool): whether the first block of gates after dope_start should be a T gate or a Clifford block.
        
            Returns:
                (pathlib.PosixPath): the path to the state folder.
        
        """
        if dope_end == None: dope_end = num_gates
        
        fname = self.special_state_template.format(N=N, input_state=input_state, n_T=n_T, num_gates=num_gates)

        fname += f'-dope_start({dope_start})'
        fname += f'-dope_end({dope_end})' if gap == None else f'-gap({gap})'
        fname += f'-LT({lead_T})'

        return Path(
                self.root_path,
                'equal_gaps',
                fname
            )


    def get_cluster_doped_state_path(self, N, input_state, n_T, num_gates, cluster_center=None, cluster_width=None):
        """ Returns the path for the folder holding a collection of randomly
            doped states where the doping is concentrated (clustered), following a normal distribution.
            
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates used to dope the circuit.

                num_gates (int): the number of gates in the circuit.

            Kwargs:
                cluster_center (int/None): the mean of the normal distribution, where the number provided indicates the gate position.

                cluster_width (float): the std of the normal distribution.
        
            Returns:
                (pathlib.PosixPath): the path to the state folder.
        
        """
        # Gets the defaults
        cluster_center, cluster_width = randqc.check_cluster_parameters(num_gates, cluster_center, cluster_width)
        fname = self.special_state_template.format(N=N, input_state=input_state, n_T=n_T, num_gates=num_gates)

        return Path(
                self.root_path,
                'cluster_doping',
                fname + f'-mean_width({cluster_center}_{cluster_width})'
            )


    #------------- State manager -------------#


    def get_state_by_serial(self, serial, data_only=True):
        """ Loads a state by its serial number. Prints an error in the case 
            where multiple states are found with the same serial number.
            
            Args:
                serial (float/str): the serial.
        
            Returns:
                (tuple): (state, path). Allows for verification via the filename the the correct state was found.
        
        """
        # Convert the serial to a proper int for its __str__ method.
        serial = int(serial)
        # Search in all of the folders for the proper state.
        paths = list(self.root_path.rglob(f'state-*-{serial}.*'))

        if len(paths) == 0:
            print(f'No states found with serial: {serial}.')
            print('Returning None...')
            return None

        if len(paths) > 1:
            print(f'Paths: {paths}.')
            print(f'Non-unique serial found with serial: {serial}.')
            print('Returning None...')
            return None

        return load_state(paths[0], data_only=data_only), paths[0]


    def get_states(self, N, input_state, instructions, topology='complete', identifier='', num_states=0, data_only=True, state_to_image=False, GUI=False):
        """ Gets states using the object's root path to find the files. In the
            case that these states don't already exist, they will be created by randqc and then loaded.
        
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                instructions (str): the circuit instructions.

        Kwargs:
                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.

                num_states (int): the number of states to get. Provide a non-positive number to load all states.

                data_only (bool): whether to load the states as numpy.ndarray's or to turn them into proper qutip.Qobj/PIL.Image's.

                state_to_image (bool): whether to convert the states to images.

                GUI (bool): whether to show a graphical loading window while loading the states.
        
            Returns:
                (list): the list of the loaded states.
        
        """
        path = paths.get_save_state_path(self.root_path, N, input_state, instructions, topology=topology, identifier=identifier)

        # Load all available states before generating more
        states = load_states(path, data_only=data_only, state_to_image=state_to_image, num_states_per_direc=num_states, verbose=self.verbose)

        if len(states) > 0 and len(states) >= num_states:
            # We've loaded all of the states we need.
            # Note that the length of the list will be greater than the number
                # requested in the case where we request all states.
            if self.verbose:
                print('States all loaded successfully.')
                print()

            return states

        ### Generate more data ###
        # No states were loaded when we requested all of them, we need to get
            # at least one
        if len(states) == 0 and num_states < 1: num_states = 1

        ### There are states missing, time to generate more ###
        states_to_generate = num_states - len(states)

        if self.verbose:
            print(f'{len(states)/num_states * 100:.1f}% of states loaded.')
            print(f'Generating the remaining {states_to_generate} states.')

        generated_states = []

        if GUI:
            bar = gui.ProgressBar(states_to_generate, title='Generating remaining states...', width=400)

        for _ in range(states_to_generate):
            # The last state return is the output of the circuit
            state = randqc.randomqc(N, instructions, input_state_label=input_state, topology=topology, identifier=identifier, save_state=True, save_path=self.root_path, GUI=False)[-1]

            generated_states.append(state)

            if GUI: bar.update()

        if GUI:
            bar.finish()

        if self.verbose:
            print('States generated.')
            # Padding
            print() 

        if data_only and not state_to_image:
            generated_states = [
                state.full()
                for state in generated_states
            ]

        if state_to_image:
            generated_states = _convert_to_images(generated_states, data_only=data_only)

        states += generated_states
        return states


    def get_scored_states(self, N, input_state, instructions, scoring_map, key=None, topology='complete', identifier='', num_states=0, state_to_image=False, data_only=True, mask_nans=False, GUI=False):
        """ Loads states based off of system parameters and generates more if 
            needed. Then scores the states using the scoring map and labels them according to the key if provided.
        
            Args:
                N (int): the number of qubits. Used for IO conventions.

                input_state (str): the initial state. Used for IO conventions.

                instructions (str): the circuit instructions. Used for IO conventions.

                scoring_map (function): a function which takes in a state and returns a list of values, i.e. regularizers for training on the data set.

            Kwargs:
                key: a marking for this collection of states (i.e. to mark them as either Clifford or Haar). Examples include 0 for Clifford, 1 for Haar, or 'clif' for Clifford, 'haar' for Haar. The data type of the key must match the data type of the scores.

                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.

                num_states (int): the number of states to load and score. Provide a non-positive int to load and score all available states.

                state_to_image (bool): whether the state should be converted to an image.

                data_only (bool): whether the full qutip.Qobj is needed or just an numpy.ndarray.

                mask_nans (bool): removes any rows with nan values.
        
                GUI (bool): whether to show a graphical loading window while loading the states.
                
            Returns:
                (numpy.ndarray): the states scored, where the 
                    last column corresponds to the key if provided.
        
        """
        states = self.get_states(N, input_state, instructions, topology=topology, identifier=identifier, num_states=num_states, data_only=data_only, state_to_image=state_to_image, GUI=GUI)

        if self.verbose:
            print('Scoring states...')

        data = score_states(states, scoring_map, key, mask_nans=mask_nans, verbose=self.verbose)

        if self.verbose:
            print('States scored.')
            print()
        return data


    def abstract_get_states(self, N, input_state, path, instructions_generator, *generator_args, num_states=0, data_only=True, state_to_image=False, GUI=False):
        """ Abstracts from rand_doping and cluster_doping and other examples 
            to generalize specially generated states. Handles loading and generating additional state data. Checks path for existing data, implements instructions_generator for generating additional data and uses path again to save this data for future loading.
        
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                path (pathlib.PosixPath): the path to the folder for
                    saving and loading data.

                instructions_generator (function): the function which generates
                    the random circuit instructions in a format that can be parsed by randqc.tools.parser.parse_instructions.

                *generator_args (list): the arguments that needed to be passed to the instructions_generator.

            Kwargs:
                num_states (int): the number of states to load. Provide a non-positive int to load and score all available states.

                data_only (bool): whether the full qutip.Qobj is needed or just an numpy.ndarray.

                state_to_image (bool): whether the state should be converted to an image.

                GUI (bool): whether to show a graphical loading progress to indicate progress.
        
            Returns:
                (list): the requested states.
        
        """
        # Make the folder in case it doesn't already exist
        path.mkdir(parents=True, exist_ok=True)
        # If it did already exist, then load any available states
        states = load_states(path, num_states, data_only=data_only, state_to_image=state_to_image, verbose=self.verbose)

        if len(states) > 0 and len(states) >= num_states:
            if self.verbose:
                print('States all loaded successfully.')
                print()

            return states

        ### Generate more data ###
        if len(states) == 0 and num_states < 1: num_states = 1

        ### There are states missing, time to generate more ###
        states_to_generate = num_states - len(states)

        if self.verbose:
            print(f'{len(states)/num_states * 100:.1f}% of states loaded.')
            print(f'Generating the remaining {states_to_generate} states.')

        generated_states = []

        if GUI:
            bar = gui.ProgressBar(states_to_generate, title='Generating states...')

        for _ in range(states_to_generate):
            # A new set of randomly doped states every time
            instructions = instructions_generator(*generator_args)
            # We need to pull the last element for the output of the circuit
            # Do not save using randqc.randomqc since we are implementing a
                # custom saving method.
            generated_state = randqc.randomqc(N, instructions=instructions, input_state_label=input_state, save_state=False)[-1]

            generated_states.append(generated_state)

            ### Save the state ###
            # We need to save the state now to save progress in the case of
                # an early script termination.
            fname = paths.get_save_state_fname(N, input_state, instructions)
            saver.save_state(generated_state, fname=path/fname)

            if GUI: bar.update()

        if GUI: bar.finish()

        if self.verbose:
            print('States generated.')
            # Padding
            print() 

        if data_only and not state_to_image:
            generated_states = [
                state.full()
                for state in generated_states
            ]

        if state_to_image:
            generated_states = _convert_to_images(generated_states, data_only=data_only)

        states += generated_states
        return states


    def get_randomly_doped_states(self, N, input_state, n_T, num_gates, num_states=0, data_only=True, state_to_image=False, GUI=False):
        """ Similar to get_states but handles randomly doped states by merging 
            the states into a single folder that share the above parameters. In most cases for randomly doped states it is not important the exact set of instructions but simply the number of qubits, the initial state, the number of T gates, and the total number of gates.
        
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates.

                num_gates (int): the total number of gates (including T gates).

            Kwargs:
                num_states (int): the number of states to load. Provide a non-positive int to load and score all available states.

                data_only (bool): whether to load the states as only data or
                    to turn them into proper qutip.Qobjs or as Image objects.

                state_to_image (bool): whether to convert the states to images.

                GUI (bool): whether to show a graphical loading progress to indicate progress.

            Returns:
                (list): the list of randomly doped states.
        
        """
        # We use a new subfolder for these states for organization
        path = self.get_randomly_doped_state_path(N, input_state, n_T, num_gates)
        # Make use of the abstracted function
        return self.abstract_get_states(N, input_state, path, randqc.rand_doping, n_T, num_gates, num_states=num_states, data_only=data_only, state_to_image=state_to_image, GUI=GUI)


    def get_num_randomly_doped_states(self, N, input_state, n_T, num_gates):
        """ Gets the number of randomly doped states available for a given N 
            and n_T. Useful for checking the amount of training/testing data exists for a classifier.
            
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates.

                num_gates (int): the total number of gates (including T gates).

            Returns:
                (int): the number of randomly doped states.
        
        """
        path = self.get_randomly_doped_state_path(N, input_state, n_T, num_gates)
        
        state_paths = list(path.glob('state-*.*'))
        return len(state_paths)


    def get_cluster_doped_states(self, N, input_state, n_T, num_gates, cluster_center=None, cluster_width=None, num_states=0, data_only=True, state_to_image=False):
        """ Samples T gate placements using a Gaussian distribution with mean: 
            cluster_center, and width: cluster_width. By doing so it ensures that while the T gates are randomly distributed, they are done so following a distribution that groups them closely together.
        
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates.

                num_gates (int): the total number of gates (including T gates).

            Kwargs:
                cluster_center (int/None): the mean of the normal distribution, where the number provided indicates the gate position.

                cluster_width (float): the std of the normal distribution.

                num_states (int): the number of states to load/generate. Pass a non-positive number to load all available states.

                data_only (bool): whether to load the states as only data or
                    to turn them into proper qutip.Qobjs or as Image objects.

                state_to_image (bool): whether to convert the states to images.

            Returns:
                (list): the list of randomly doped states.
        
        """
        # Sets the default parameters
        cluster_center, cluster_width = randqc.check_cluster_parameters(num_gates, cludster_center, cluster_width)

        # We use a new subfolder for these states for organization
        path = self.get_cluster_doped_state_path(N, input_state, n_T, num_gates, cluster_center=cluster_center, cluster_width=cluster_width)
        # Make use of the abstracted function
        return self.abstract_get_states(N, input_state, path, randqc.cluster_doping, n_T, num_gates, cluster_center, cluster_width, num_states=num_states, data_only=data_only, state_to_image=state_to_image)


    def get_equal_gap_states(self, N, input_state, n_T, num_gates, dope_start=1, dope_end=None, gap=None, lead_T=False, num_states=0, data_only=True, state_to_image=False):
        """ Gets states with T gates that have an equal gap of Clifford gates 
            between them. An example set of instructions might be: Clx100;Tx1;Clx100;Tx1;Clx100. This would be generated with: n_T=2, num_gates=302, dope_start=1, gap=100, lead_T=False.
            
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates used to dope the circuit.

                num_gates (int): the number of gates in the circuit.

            Kwargs:
                dope_start (int): the position of the first gate (inclusively) for where doping is allowed to happen.

                dope_end (int/None): the position of the last gate (inclusively) for where doping is allowed to happen. Defaults to num_gates if None is provided.

                gap (int/None): the number of Clifford gates that should separate each T gate. Defaults to an equal space based on the number of gates requested if None is provided.

                lead_T (bool): whether the circuit should begin with a T gate or begin with the Clifford gap. Affects circuit instructions. Example: n_T=2, num_gates=302 lead_T=False: 2*(Clx100,Tx1);Clx100. lead_T=True: 2*(Tx1,Clx100);Clx100.
        
            Returns:
                (list): the list of cluster doped states.
        
        """
        if dope_end == None: dope_end = num_gates
        
        path = self.get_equal_gap_state_path(N, input_state, n_T, num_gates, dope_start=dope_start, dope_end=dope_end, gap=gap, lead_T=lead_T)

        return self.abstract_get_states(N, input_state, path, randqc.equal_gap_doping, n_T, num_gates, dope_start, dope_end, gap, lead_T, num_states=num_states, data_only=data_only, state_to_image=state_to_image)


    def get_scored_randomly_doped_states(self, N, input_state, n_T, num_gates, scoring_map, key=None, num_states=0, data_only=True, state_to_image=False, mask_nans=False, GUI=False):
        """ Loads randomly doped states and scores them.
        
            Args:
                N (int): the number of qubits.

                input_state (str): the initial state.

                n_T (int): the number of T gates.

                num_gates (int): the total number of gates (including T gates).

                scoring_map (function): a function which takes in a state and returns a list of values, i.e. regularizers for training on the data set.

            Kwargs:
                key: a marking for this collection of states (i.e. to mark them as either Clifford or Haar). Examples include 0 for Clifford, 1 for Haar, or 'clif' for Clifford, 'haar' for Haar. The data type of the key must match the data type of the scores.

                num_states (int): the number of states to load and score. Provide a non-positive int to load and score all available states.

                data_only (bool): whether to load the states as only data or
                    to turn them into proper qutip.Qobjs or as Image objects.

                state_to_image (bool): whether to convert the states to images.

                mask_nans (bool): removes any rows with nan values.

                GUI (bool): whether to show a graphical loading progress to indicate progress.

            Returns:
                (list): the scores.
        
        """

        states = self.get_randomly_doped_states(N, input_state, n_T, num_gates, num_states, data_only=data_only, state_to_image=state_to_image, GUI=GUI)

        if self.verbose:
            print('Scoring states')
        data = score_states(states, scoring_map, key, mask_nans=mask_nans, verbose=self.verbose, GUI=GUI)

        if self.verbose:
            print('States scored.')
            print()
        return data

        
    #------------- Entropy manager -------------#


    def init_abstract_get_data(self, path_func):
        """ Initializes self.abstract_get_data function by taking in a
            path generator to an entropies.txt data file so that loader.Loader can handle dynamically loading data files for different systems.
        
            Args:
                path_func (function): a generator which provides the path to the data file.
        
            Returns:
                (function): the abstract_get_data function.
        
        """
        return lambda *args, num_trials=0, serials=False : self.abstract_get_data(path_func, *args, num_trials=num_trials, serials=serials)


    def abstract_get_data(self, path_func, *args, num_trials=0, serials=False):
        """ Abstraction of self.get_entropies. Handles loading in entropy data 
            for systems with different saving conventions.
        
            Args:
                path_func (function): the path generator.

                *args (list): any arguments the path generator requires.

                num_trials (int): the number of trials the entropy data was gathered for. Use a non-positive number to gather all of it.

                serials (bool): data gathered will contain serials (if serialized). With this flag set to True this function will separately return the serials, if False only the entropy data will be returned.
        
            Returns:
                (numpy.ndarray): the entropy data.
        
        """
        data_path = path_func(*args)

        # Prepend the base folder path since path_func provides the relative
            # path
        data_path = self.root_path / data_path

        data = load_data(data_path, num_trials=num_trials, verbose=False)

        # Reset the number of trials if we request
        if data.shape[0] == 0 and num_trials < 1:
            # No data was loaded
            num_trials = 1
        elif data.shape[0] > 0 and num_trials < 1:
            # Data was loaded and we loaded all of it
            num_trials = data.shape[0]

        if self.verbose:
            print(f'{data.shape[0]/num_trials * 100:.1f}% of data loaded.')

        ### Handles returning data and serialization ###

        if is_serialized(data):
            # The data has its own serials in the first column.
            serials_list = data[:, 0]
            # Remaining columns of data will be actual entropy data
            data = data[:, 1:]

            if serials:
                # We want the provide the serials
                return data, serials_list

            # Serial data is not wanted
            return data

        # The data is unserialized
        if serials:
            # Serial data is wanted despite having none:
            return data, []

        # No serial data is wanted anyways
        return data


    def get_entropies(self, N, input_state, instructions, bipartition=None, renyi_parameter=1, topology='complete', identifier='', num_trials=0, serials=False, GUI=False):
        """ Gets the entropy data requested using the object's root path to 
            find the files. In the case where the data does not exist or is insufficient, more will be generated by randqc and then loaded.
        
            Args:
                N (int): the number of qubits in the system.

                input_state (str): the initial state.

                instructions (str): the circuit instructions.

            Kwargs:
                bipartition (int/None): the bipartition used. Defaults to N//2 when None is provided.

                renyi_parameter (float): the type of Renyi entropy gathered.

                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.

                num_trials (int): the number of trials the entropy data was gathered for. Use a non-positive number to gather all of it.

                serials (bool): data gathered will contain serials (if serialized). With this flag set to True this function will separately return the serials, if False only the entropy data will be returned.

                GUI (bool): whether to show a graphical loading bar to indicate progress.
        
            Returns:
                (numpy.ndarray/2-tuple): the matrix of entropy data. Each row consists of a trial and each column consists of a gate, so the matrix will be of dimension: (num_trials)x(num_gates + 1) where the shift to the column accounts for the entropy of the initial state. If serials flag is provided then a 2-tuple will be returned with the first component being the entropy data and the second one being the serials of each row.
        
        
        """
        # This function does not make use of the abstract get_data since it 
            # has its own method for collecting further data while the 
            # abstracted version currently does not.

        if bipartition == None: bipartition = N // 2

        # Load any existing data
        fname = paths.get_entropy_file_path(self.root_path, N, input_state, instructions, topology=topology, bipartition=bipartition, renyi_parameter=renyi_parameter, identifier=identifier)
        # Turn off the print statements since the states will be 
            # faux-serialized in the case that they are unserialized.
        data = load_data(fname, num_trials=num_trials, verbose=False)

        # Reset the number of trials if we request
        if data.shape[0] == 0 and num_trials < 1:
            # No data was loaded
            num_trials = 1
        elif data.shape[0] > 0 and num_trials < 1:
            # Data was loaded and we loaded all of it
            num_trials = data.shape[0]

        ### Generate missing data ###
        if self.verbose:
            print(f'{data.shape[0]/num_trials * 100:.1f}% of entropy data loaded.')

        remaining_trials = num_trials - data.shape[0]

        ### Generate remaining trials ###

        if remaining_trials > 0:
            if GUI:
                bar = gui.ProgressBar(remaining_trials, title=f'Generating remaining {remaining_trials} trials...', width=300)
            elif self.verbose:
                print(f'Generating the remaining {remaining_trials} trials.')

            if not is_serialized(data):
                # Add a faux serial if this data is unserialized.
                # We must generate faux-serials in order for more data to be 
                    # gathered.
                # Division by two means this data was gathered in the year 
                    # ~2010. Clearly a fake serial.
                faux_serial = -float(parser.get_serial()) / 2
                # Adjust the proper dimensions for hstack
                faux_serials = np.array([
                    faux_serial
                    for _ in range(data.shape[0])
                ]).reshape(data.shape[0], 1)

                # Prepend the faux-serials to the first column.
                data = np.hstack(( faux_serials, data ))

            for _ in range(remaining_trials):
                _, trial_data = randqc.randomqc(N, instructions, input_state_label=input_state, topology=topology, bipartition=bipartition, renyi_parameter=renyi_parameter, save_data=True, save_path=self.root_path)

                # Cannot vertically stack in the case where no data exists so 
                    # we just assign the data to be our trial data.
                data = np.vstack((data, trial_data)) if data.shape[0] != 0 else trial_data

                if GUI: bar.update()

            if GUI: bar.finish()

        ### Handles returning data and serialization ###

        if is_serialized(data):
            # The data has its own serials in the first column.
            # Serials are negative for easy distinction from entropy data.
            serials_list = np.abs(data[:, 0])
            # Remaining columns of data will be actual entropy data
            data = data[:, 1:]

            if serials:
                # We want the provide the serials
                return data, serials_list

            # Serial data is not wanted
            return data

        # The data is unserialized
        if serials:
            # Serial data is wanted despite having none:
            return data, []

        # No serial data is wanted anyways
        return data


    def get_data(self, N, input_state, instructions, map_name, topology='complete', identifier='', num_trials=0, serials=False, GUI=False):
        """ Gets the data for a custom state map requested using the object's 
            root path to find the files.
        
            Args:
                N (int): the number of qubits in the system.

                input_state (str): the initial state.

                instructions (str): the circuit instructions.

                map_name (str): the name of the map to distinguish from other quantities of interest.

            Kwargs:
                topology (str): the topology of the circuit applied to the state.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.

                num_trials (int): the number of trials the entropy data was gathered for. Use a non-positive number to gather all of it.

                serials (bool): data gathered will contain serials (if serialized). With this flag set to True this function will separately return the serials, if False only the entropy data will be returned.

                GUI (bool): whether to show a graphical loading bar to indicate progress.
        
            Returns:
                (numpy.ndarray/2-tuple): the matrix of data. Each row consists of a trial and each column consists of a gate, so the matrix will be of dimension: (num_trials)x(num_gates + 1) where the shift to the column accounts for the data of the initial state. If serials flag is provided then a 2-tuple will be returned with the first component being the entropy data and the second one being the serials of each row.
        """
        return self.abstract_get_data(paths.get_data_file_path, self.root_path, N, input_state, instructions, map_name, topology, identifier, num_trials=num_trials, serials=serials)


    def get_num_entropy_trials(self, N, input_state, instructions, topology='complete', bipartition=None, renyi_parameter=1, identifier=''):
        """ Gets the number of entropy trials completed. In the case of an 
            .hdf5 file the matrix does not need to be loaded into memory.
            
            Args:
                N (int): the number of qubits in the system.

                input_state (str): the initial state.

                instructions (str): the circuit instructions.

            Kwargs:
                topology (str): the topology of the circuit applied to the state.

                bipartition (int/None): the bipartition used. Defaults to N//2 when None is provided.

                renyi_parameter (float): the type of Renyi entropy gathered.

                identifier (str): optional additional string that may be used to identify and separate this folder path from others.
        
            Returns:
                (int): the number of trials completed for entropy data. Corresponds to the number of rows in the entropy data matrix.
        
        """
        # Get path since we want to avoid loading the entire matrix into 
            # memory.
        fname = paths.get_entropy_file_path(self.root_path, N, input_state, instructions, bipartition=bipartition, renyi_parameter=renyi_parameter, topology=topology, identifier=identifier)

        fstem = str(fname.stem)
        if ']' in fstem:
            fstem = fstem.split(']')[0]

        to_load = list(fname.parent.glob(fstem + '*'))

        trial_count = 0

        # If there is more data we need to append it to this one
        for fname in to_load:
            
            # Checks extension for legacy support
            if fname.suffix == '.hdf5':
                with h5py.File(fname, 'r') as f:
                    trial_count += f['default'].len()
            elif fname.suffix == '.npy':
                trial_count += np.load(fname).shape[0]
            elif fname.suffix == '.txt':
                trial_count += np.loadtxt(fname).shape[0]
            else:
                print(f'Invalid entropy file type: {fname}. Skipping...')
                continue


        return trial_count



    #------------- End Loader -------------#


#------------- Entry code -------------#

def main():
    print('loader.py')
    
    # Testing loader
    state_loader = Loader('~/RandQC/Testing')


if __name__ == '__main__':
    main()